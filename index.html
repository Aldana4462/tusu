<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>La CÃ¡psula</title>
<style>
html,body{margin:0;padding:0;background:#000;color:#fff;height:100%;overflow:hidden;font-family:'Montserrat',Arial,sans-serif;}
canvas{position:fixed;top:0;left:0;width:100%;height:100%;display:block;}
.tooltip{position:fixed;background:rgba(0,0,0,0.8);color:#fff;padding:6px 10px;border-radius:4px;font-size:14px;pointer-events:none;white-space:nowrap;display:none;z-index:10}
</style>
</head>
<body>
<canvas id="field"></canvas>
<div id="tooltip" class="tooltip"></div>
<script>
const TOTAL=10000;      // total bubbles
const FRONT=9;          // bubbles considered in the foreground
const canvas=document.getElementById('field');
const ctx=canvas.getContext('2d');
const tooltip=document.getElementById('tooltip');
let w=0,h=0;            // canvas dimensions
const rand=(a,b)=>Math.random()*(b-a)+a;
// resize canvas to fill screen
function resize(){w=canvas.width=window.innerWidth;h=canvas.height=window.innerHeight;}
window.addEventListener('resize',resize);resize();

/* Generate bubble data. To avoid DOM overhead we store data in memory and render on canvas. */
const bubbles=[];
for(let y=0;y<100;y++){
  for(let x=0;x<100;x++){
    const id=y*100+x+1;
    bubbles.push({
      id,
      hue:(id*137.5)%360,          // unique color used for "photo"
      message:`Bubble #${id}`,
      baseX:x+Math.random(),       // grid distribution with randomness
      baseY:y+Math.random(),
      baseZ:rand(-1000,-300),
      ampX:rand(5,15),ampY:rand(5,15),ampZ:rand(200,400),
      phaseX:rand(0,Math.PI*2),phaseY:rand(0,Math.PI*2),phaseZ:rand(0,Math.PI*2),
      speed:rand(0.1,0.4),
      x:0,y:0,z:0,sx:0,sy:0,scale:0,frontR:0
    });
  }
}

// subtle background particle stars
const stars=[];
for(let i=0;i<25;i++)stars.push({x:Math.random()*w,y:Math.random()*h,size:rand(1,3),
  base:rand(0.1,0.3),amp:rand(0.05,0.2),phase:Math.random()*6,speed:rand(0.1,0.3)});

let fronts=[]; // indices of foreground bubbles each frame

// helper to insert candidate bubble into fronts array keeping z-order and avoiding overlap
function tryAddFront(idx){
  const b=bubbles[idx];
  const r=b.frontR;
  // find insertion point by depth (descending z)
  let pos=fronts.length;
  while(pos>0 && bubbles[fronts[pos-1]].z<b.z)pos--;
  // overlap check with existing front bubbles
  for(const fi of fronts){
    const o=bubbles[fi];
    const dx=b.sx-o.sx,dy=b.sy-o.sy;const min=r+o.frontR;
    if(dx*dx+dy*dy<min*min)return; // overlap too much
  }
  fronts.splice(pos,0,idx);
  if(fronts.length>FRONT)fronts.pop();
}

let start=performance.now();
function loop(now){
  const t=(now-start)/1000;
  ctx.clearRect(0,0,w,h);
  // animated radial background glow
  const g=ctx.createRadialGradient(w/2,h*0.6,0,w/2,h*0.6,Math.max(w,h));
  g.addColorStop(0,'rgba(30,30,50,'+(0.2+Math.sin(t*0.5)*0.1)+')');
  g.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=g;ctx.fillRect(0,0,w,h);
  // draw drifting stars
  for(const s of stars){
    const op=s.base+Math.sin(t*s.speed+s.phase)*s.amp;
    ctx.fillStyle=`rgba(200,220,255,${op})`;
    ctx.beginPath();ctx.arc(s.x, s.y, s.size,0,Math.PI*2);ctx.fill();
  }
  fronts=[];
  // update and draw far bubbles (non-front)
  for(let i=0;i<TOTAL;i++){
    const b=bubbles[i];
    const tt=t*b.speed;
    b.x=b.baseX+Math.sin(tt+b.phaseX)*b.ampX;
    b.y=b.baseY+Math.cos(tt+b.phaseY)*b.ampY;
    b.z=b.baseZ+Math.sin(tt+b.phaseZ)*b.ampZ;
    b.scale=0.3+(b.z+1000)/800; // 0.3..1.55
    b.sx=b.x/100*w;
    b.sy=b.y/100*h;
    b.frontR=20*b.scale; // radius if considered foreground
    const r=4*b.scale;   // default radius for far bubbles
    // candidate for foreground if close enough to camera
    if(b.z>-150)tryAddFront(i);
    // draw small distant bubble
    ctx.fillStyle=`hsla(${b.hue},70%,70%,${0.3+b.scale*0.3})`;
    ctx.beginPath();ctx.arc(b.sx,b.sy,r,0,Math.PI*2);ctx.fill();
  }
  // draw front bubbles with more detail (sorted already)
  for(const idx of fronts){
    const b=bubbles[idx];
    const r=b.frontR;
    const grad=ctx.createRadialGradient(b.sx,b.sy-r*0.6,r*0.1,b.sx,b.sy,r);
    grad.addColorStop(0,`hsla(${b.hue},70%,95%,0.9)`);
    grad.addColorStop(0.6,`hsla(${b.hue},70%,60%,0.7)`);
    grad.addColorStop(1,'rgba(255,255,255,0.2)');
    ctx.fillStyle=grad;
    ctx.beginPath();ctx.arc(b.sx,b.sy,r,0,Math.PI*2);ctx.fill();
    ctx.lineWidth=1;ctx.strokeStyle='rgba(255,255,255,0.8)';ctx.stroke();
    ctx.fillStyle='#fff';
    ctx.font=`${r*0.9}px Montserrat,Arial,sans-serif`;
    ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(b.id,b.sx,b.sy);
  }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Tooltip interaction for foreground bubbles
canvas.addEventListener('mousemove',e=>{
  const rect=canvas.getBoundingClientRect();
  const x=e.clientX-rect.left,y=e.clientY-rect.top;
  let found=null;
  for(const idx of fronts){
    const b=bubbles[idx];
    const dx=x-b.sx,dy=y-b.sy;
    if(dx*dx+dy*dy<b.frontR*b.frontR){found=b;break;}
  }
  if(found){
    tooltip.textContent=found.message;
    tooltip.style.left=(e.clientX+10)+'px';
    tooltip.style.top=(e.clientY-20)+'px';
    tooltip.style.display='block';
  }else tooltip.style.display='none';
});
canvas.addEventListener('mouseleave',()=>tooltip.style.display='none');
</script>
</body>
</html>
